{% extends "layouts/base.html" %}

{% block selections %}
<div class="img-zoom-container">
  <div class="img-zoom-image">
    <img id="myimage" src="{{court_pic}}" alt="Image from camera is missing" height="400">
  </div>
  <div id="myresult" class="img-zoom-result">
    <canvas id="zoom-canvas" width="256" height="256" ></canvas>
  </div>
  <div class="calibration_controls">
    <div>
      <input type="button" value="&#x21A5" onclick="move_up()">
      <input type="button" value="&#x21A7" onclick="move_down()">
      <br>
      <input type="button" value="&#x21A4" onclick="move_left()">
      <input type="button" value="&#x21A6" onclick="move_right()">
      <br>
      <input type="button" value="Set Intersection" onclick="set_point()">
      <input type="button" value="Fini" onclick="send_points()">
      <p id="current_x_y">Current X: ___ Y: ___</p>
    </div>
    <hr>
    <div>
      <p id="fbl_x_y">Far Baseline Left   X: ___ Y: ___</p>
      <p id="fbr_x_y">Far Baseline Right  X: ___ Y: ___</p>
      <p id="nsl_x_y">Near Service Left   X: ___ Y: ___</p>
      <p id="nsc_x_y">Near Service Center X: ___ Y: ___</p>
      <p id="nsr_x_y">Near Service Right  X: ___ Y: ___</p>
      <p id="nbl_x_y">Near Baseline Left  X: ___ Y: ___</p>
      <p id="nbr_x_y">Near Baseline Right X: ___ Y: ___</p>
    </div>
  </div>
</div>

<style media="all">
.calibration_controls {
  display: inline-block;
  border: 1px solid #d4d4d4;
}
.calibration_controls p, label, input[type="number"] {
  font-size: 24px;
  color: white;
  background: #555555;
  padding: 1px;
  border: 2px solid #494949;
  margin-top: 0;
  margin-bottom: 0;
 }
 .calibration_controls input[type="button"] {
  width: 60px;
  font-size: 32px;
  color: white;
  background: #555555;
  padding: 1px;
  border: 2px solid #494949;
  display: inline-block;
}
/*
  * {box-sizing: border-box;}
*/
.img-zoom-container {
  position: relative;
  vertical-align: top;
}
.img-zoom-image {
  display: inline-block;
  border: 1px solid #d4d4d4;
  height: 400px;
  vertical-align: top;
}
.img-zoom-lens {
  position: absolute;
  /* border: 1px solid #d4d4d4; */
  border: 2px solid #702727;
  /*set the size of the lens:*/
  width: 16px;
  height: 16px;
}
.img-zoom-result {
  vertical-align: top;
  display: inline-block;
  border: 1px solid #d4d4d4;
  width: 256px;
  height: 256px;
  cursor: None;
  image-rendering: pixelated;
  /* cursor: crosshair; */
  /* cursor: url('static/cursor-close.png'), auto; */
}
</style>
{% endblock %}


{% block control %}

{% endblock %}

{% block page_specific_js %} 
<script>
  var canvas;
  var contxt;
  var x_px_selector, y_px_selector;
  var x_px, y_px;
  let move_px = 8;
  var background_top, background_left;
  var coords = {};
  var left;

  window.addEventListener('load', (event) => {
    // console.log('The page has fully loaded');
    imageZoom("myimage", "myresult");
    canvas = document.getElementById("zoom-canvas");
    contxt = canvas.getContext("2d");
    background_top = background_left = 0;
    x_px_selector = canvas.width/2;
    y_px_selector = canvas.height/2;
    left = (document.getElementById("mode").innerText.substring(6,7).toLowerCase() === "l") ? true : false;
    draw();
  });

  function draw() {
    contxt.clearRect(0, 0, canvas.width, canvas.height);
    // contxt.beginPath();
    // // x, y, radius, starting angle, ending angle
    // contxt.arc((x_px_selector-3), (y_px_selector-3), 6, 0, 2 * Math.PI);
    // contxt.lineWidth = 3;
    // contxt.strokeStyle = "Chartreuse";
    // contxt.setLineDash([2]);
    // contxt.stroke();
    let len_half_line = 8;
    contxt.beginPath();
  // contxt.setLineDash([2]);
    contxt.strokeStyle = "Chartreuse";
    contxt.lineWidth = 1;
    contxt.moveTo(x_px_selector-len_half_line, y_px_selector);
    contxt.lineTo(x_px_selector+len_half_line, y_px_selector);
    contxt.moveTo(x_px_selector, y_px_selector-len_half_line);
    contxt.lineTo(x_px_selector, y_px_selector+len_half_line);
    contxt.stroke();   

    contxt.beginPath();
    contxt.strokeStyle = "DarkGreen";
    contxt.lineWidth = 1;
    contxt.moveTo(x_px_selector-len_half_line, y_px_selector-len_half_line);
    contxt.lineTo(x_px_selector+len_half_line, y_px_selector+len_half_line);
    contxt.moveTo(x_px_selector-len_half_line, y_px_selector+len_half_line);
    contxt.lineTo(x_px_selector+len_half_line, y_px_selector-len_half_line);
    contxt.stroke();   

    // the 1280x800 image is displayed at 640x400, so double the left/top to get the pixel on the real image
    console.log("background left: %d  top: %d", background_left, background_top); 
    x_px = (background_left*2) + (x_px_selector/move_px - 1);
    y_px = (background_top *2) + (y_px_selector/move_px -1);
    var current_x_y = document.getElementById('current_x_y');
    current_x_y.innerText = `Current X: ${x_px} Y: ${y_px}`;
  }
  function move_down() {
    if (y_px_selector < (canvas.height - move_px))
      y_px_selector += move_px;
    draw();
  }
  function move_up() {
    if (y_px_selector > move_px)
      y_px_selector -= move_px;
    draw();
  }
  function move_right() {
    if (x_px_selector < (canvas.width - move_px))
      x_px_selector += move_px;
    draw();
  }
  function move_left() {
    if (x_px_selector > move_px)
      x_px_selector -= move_px;
    draw();
  }
  function set_point() {
    // the following define x/y areas for the 7 coordinates: Near/Far(y) Baseline Left/Right (x), and ServiceLine
    // console.log("Value of left on set_point: " + left);
    var fb_y_max = 100;
    var fb_x_max = left ? 500 : 1000;
    var ns_y_min = 220;
    var ns_y_max = left ? 425 : 375;
    var nsl_x_max = left ? 440 : 640;
    var nsc_x_max = left ? 730 : 900;
    var nb_x_max = 500;

    if (y_px < fb_y_max) {
      // set far base line left or right
      if (x_px < fb_x_max) {
        coords["fblx"] = x_px; coords["fbly"] = y_px;
        var fbl_x_y = document.getElementById('fbl_x_y');
        fbl_x_y.innerText = `Far-BaseLine-Left: X: ${x_px} Y: ${y_px}`;
      } else {
        coords["fbrx"] = x_px; coords["fbry"] = y_px;
        var fbr_x_y = document.getElementById('fbr_x_y');
        fbr_x_y.innerText = `Far-BaseLine-Right: X: ${x_px} Y: ${y_px}`;
      }
    } else if (y_px > ns_y_min && y_px < ns_y_max) {
      // set far near service line left, center or right
      if (x_px < nsl_x_max) {
        coords["nslx"] = x_px; coords["nsly"] = y_px;
        var nsl_x_y = document.getElementById('nsl_x_y');
        nsl_x_y.innerText = `Near-ServiceLine-Left: X: ${x_px} Y: ${y_px}`;
      } else if (x_px > nsl_x_max && x_px < nsc_x_max) {
        coords["nscx"] = x_px; coords["nscy"] = y_px;
        var nsc_x_y = document.getElementById('nsc_x_y');
        nsc_x_y.innerText = `Near-ServiceLine-Center: X: ${x_px} Y: ${y_px}`;
      } else {
        coords["nsrx"] = x_px; coords["nsry"] = y_px;
        var nsr_x_y = document.getElementById('nsr_x_y');
        nsr_x_y.innerText = `Near-ServiceLine-Right: X: ${x_px} Y: ${y_px}`;
      }
    } else if (y_px > ns_y_max) {
      // set near base line left or right
      if (x_px < nb_x_max) {
        coords["nblx"] = x_px; coords["nbly"] = y_px;
        var nbl_x_y = document.getElementById('nbl_x_y');
        nbl_x_y.innerText = `Near-BaseLine-Left: X: ${x_px} Y: ${y_px}`;
      } else {
        coords["nbrx"] = x_px; coords["nbry"] = y_px;
        var nbr_x_y = document.getElementById('nbr_x_y');
        nbr_x_y.innerText = `Near-BaseLine-Right: X: ${x_px} Y: ${y_px}`;
      }
    } else {
      console.log("y_px: %d is out of bounds", y_px)
    }
  }

  // for 2 different methods to post coord, refer to: https://stackoverflow.com/questions/6396101/pure-javascript-send-post-data-without-a-form

  function send_points() {
    var number_of_calib_points = 7;

    if (Object.keys(coords).length < number_of_calib_points * 2)
    {
      window.alert("Please finish setting all " + number_of_calib_points + " coordinates.");
    } else
    {
      // not reporting CAM left/right; web-ctrl has it has it a a global
      // coords["cam"] = document.getElementById("mode").innerText.substring(6,7);
      var xhr = new XMLHttpRequest();
      xhr.open("POST", "/calib_done", true);
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.send(JSON.stringify(coords));
      // used the following to get webpage update after the post; there is probably a better way
      window.location.replace('/calib_done');
    }
  }
</script>
  
<script type="text/javascript">
function imageZoom(imgID, resultID) {
  var img, lens, result, cx, cy;
  img = document.getElementById(imgID);
  result = document.getElementById(resultID);
  /* Create lens: */
  lens = document.createElement("DIV");
  lens.setAttribute("class", "img-zoom-lens");
  lens.id = "LENS"
  /* Insert lens: */
  img.parentElement.insertBefore(lens, img);
  /* Calculate the ratio between result DIV and lens: */
  lens_style = getComputedStyle(lens);
  let lens_borderTotal = (parseInt(lens_style.borderLeftWidth) || 0) * 2;
  result_style = getComputedStyle(result);
  let result_borderTotal = (parseInt(result_style.borderLeftWidth) || 0) *2;
  cx = (result.offsetWidth - result_borderTotal) / (lens.offsetWidth - lens_borderTotal);
  cy = (result.offsetHeight - result_borderTotal) / (lens.offsetHeight - lens_borderTotal);
  // console.log("result.offsetWidth & Height: %d x %d   lens.offsetWidth & Height: %d x %d", result.offsetWidth, result.offsetHeight, lens.offsetWidth, lens.offsetHeight);
  // console.log("lens_borderTotal: %d   result_borderTotal: %d  cx: %d  cy: %d", lens_borderTotal, result_borderTotal, cx, cy);

  /* Set background properties for the result DIV */
  result.style.backgroundImage = "url('" + img.src + "')";
  result.style.backgroundSize = (img.width * cx) + "px " + (img.height * cy) + "px";
  /* Execute a function when someone moves the cursor over the image, or the lens: */
  lens.addEventListener("mousedown", moveLens);
  img.addEventListener("mousedown", moveLens);
  /* And also for touch screens: */
  lens.addEventListener("touchmove", moveLens);
  img.addEventListener("touchmove", moveLens);
  function moveLens(e) {
    var pos, x, y;
    /* Prevent any other actions that may occur when moving over the image */
    e.preventDefault();
    /* Get the cursor's x and y positions: */
    pos = getCursorPos(e);
    /* Calculate the top & left of the lens - placing the cursor at the center of the lens
       x -> horizontal left to right, e.g. Width.
      img.width & height do NOT include the border
      lens.offsetHeight & Width DO include the border
    */
    background_top = pos.y - (lens.offsetWidth/2);
    background_left = pos.x - (lens.offsetHeight/2);
    lens_top = background_top + lens_borderTotal/2;
    lens_left = background_left + lens_borderTotal/2;

    /* Prevent the background from being positioned outside the image */
    if (background_top < 0) {
      background_top = 0;
      lens_top = -1;
    }
    background_top_limit = img.height - lens.offsetHeight + lens_borderTotal;
    if (background_top > background_top_limit) {
      background_top = background_top_limit;
      lens_top = background_top + 1;
    }
    if (background_left < 0) {
      background_left = 0;
      lens_left = -1;
    }
    background_left_limit = img.width - lens.offsetWidth + lens_borderTotal;
    if (background_left > background_left_limit) {
      background_left = background_left_limit;
      lens_left = background_left + 1;
    }

    /* position the lens based on the background; add in the border
     */
    console.log("cursor x: %d  y: %d    backg left: %d  top: %d    lens left: %d  top: %d", pos.x, pos.y, background_left, background_top, lens_left, lens_top);
    /* Prevent the lens from being positioned outside the image:  (BUT: OK to have lens border outside the image
       on the zero sides, allow the lens to overlap the image border - hence limit to -1
       on the other side, have the lens be inside the img.height/widht - the lens size not including the border
    */
    // if (x > img.width - lens.offsetWidth) {x = img.width - lens.offsetWidth;}
    // if (x < 0) {x = 0;}
    // if (y > img.height - lens.offsetHeight) {y = img.height - lens.offsetHeight;}
    // if (y < 0) {y = 0;}
    // console.log("img.width: %d  img.height: %d   img.offsetWidth: %d  img.offsetHeight: %d", img.width, img.height, img.offsetWidth, img.offsetHeight);
    /* Set the position of the lens: */
    lens.style.left = lens_left + "px";
    lens.style.top = lens_top + "px";
    /* Display what the lens "sees": */
    // result.style.backgroundPosition = "-" + (x * cx) + "px -" + (y * cy) + "px";
    result.style.backgroundPosition = "-" + (background_left * cx) + "px -" + (background_top * cy) + "px";

    // reset the pixel selectors to the middle
    x_px_selector = canvas.width/2
    y_px_selector = canvas.height/2
    draw()
  }
  function getCursorPos(e) {
    var a, x = 0, y = 0;
    e = e || window.event;
    /* Get the x and y positions of the image: */
    a = img.getBoundingClientRect();
    /* Calculate the cursor's x and y current_x_y, relative to the image: */
    x = e.pageX - a.left;
    y = e.pageY - a.top;
    /* Consider any page scrolling: */
    x = x - window.pageXOffset;
    y = y - window.pageYOffset;
    return {x : x, y : y};
  }
}
</script>
{% endblock %} 